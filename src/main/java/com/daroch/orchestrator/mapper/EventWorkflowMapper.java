package com.daroch.orchestrator.mapper;

import com.daroch.orchestrator.dto.api.request.CreateEventRequest;
import com.daroch.orchestrator.dto.api.response.CreateEventResponse;
import com.daroch.orchestrator.dto.eventservice.request.EventServiceCreateEventRequest;
import com.daroch.orchestrator.dto.eventservice.response.EventServiceCreateEventResponse;
import com.daroch.orchestrator.dto.ticketservice.request.TicketServiceCreateTicketTypeRequest;
import com.daroch.orchestrator.dto.ticketservice.response.TicketServiceCreateTicketTypeResponse;
import java.util.List;
import java.util.UUID;
import org.springframework.stereotype.Component;

/**
 * Mapper responsible for translating API-level orchestration requests into downstream
 * service-specific request DTOs.
 *
 * <p>This mapper is intentionally NOT a generic entity mapper. It exists to support orchestration
 * workflows where:
 *
 * <ul>
 *   <li>One incoming API request fan-outs into multiple service calls
 *   <li>Additional runtime data (e.g. eventId) must be injected
 *   <li>Each downstream service has its own isolated contract
 * </ul>
 *
 * <p>No business logic, persistence, or network calls belong here. This class performs structural
 * transformations only.
 */
@Component
public class EventWorkflowMapper {

  /**
   * Maps the orchestrator API request to the Event Service create-event request.
   *
   * <p>This method extracts only the fields relevant to event creation. Ticket-related data is
   * intentionally ignored here and handled in a separate mapping step after the event is created.
   *
   * @param apiRequest the incoming API request received by the orchestrator
   * @return a request DTO compatible with the Event Service contract
   */
  public EventServiceCreateEventRequest toEventServiceRequest(CreateEventRequest apiRequest) {

    EventServiceCreateEventRequest req = new EventServiceCreateEventRequest();
    req.setName(apiRequest.getName());
    req.setStartDate(apiRequest.getStartDate());
    req.setEndDate(apiRequest.getEndDate());
    req.setVenue(apiRequest.getVenue());
    req.setSalesStartDate(apiRequest.getSalesStartDate());
    req.setSalesEndDate(apiRequest.getSalesEndDate());
    req.setStatus(apiRequest.getStatus());

    return req;
  }

  /**
   * Maps API-level ticket type definitions into Ticket Service requests.
   *
   * <p>This method must be called only AFTER the event has been successfully created, because the
   * {@code eventId} is generated by the Event Service and injected here as part of the
   * orchestration flow.
   *
   * <p>If no ticket types are provided in the API request, an empty list is returned and no ticket
   * service call should be made.
   *
   * @param eventId the identifier of the newly created event
   * @param apiRequest the original API request containing ticket definitions
   * @return a list of Ticket Service create-ticket-type requests
   */
  public List<TicketServiceCreateTicketTypeRequest> toTicketServiceRequests(
      UUID eventId, CreateEventRequest apiRequest) {

    if (apiRequest.getTicketTypes() == null || apiRequest.getTicketTypes().isEmpty()) {
      return List.of();
    }

    return apiRequest.getTicketTypes().stream()
        .map(
            ticket -> {
              TicketServiceCreateTicketTypeRequest req = new TicketServiceCreateTicketTypeRequest();

              // eventId is injected by the orchestrator after event creation
              req.setEventId(eventId);
              req.setName(ticket.getName());
              req.setPrice(ticket.getPrice());
              req.setDescription(ticket.getDescription());
              req.setTotalAvailable(ticket.getTotalAvailable());
              req.setStatus(ticket.getStatus());

              return req;
            })
        .toList();
  }

  /**
   * Assembles the public API response for event creation by composing data returned from the Event
   * Service and Ticket Service.
   *
   * <p>This method performs deterministic DTO composition only. It does not contain workflow
   * decisions, service calls, or error handling logic.
   *
   * <p>The event-related fields are sourced from the Event Service response, while the list of
   * created ticket types is attached as-is from the Ticket Service response.
   *
   * @param eventResponse the response returned by the Event Service after successfully creating an
   *     event
   * @param ticketResponses the list of ticket types created for the event, as returned by the
   *     Ticket Service
   * @return a fully assembled {@link CreateEventResponse} suitable for returning to API clients
   */
  public CreateEventResponse toCreateEventResponse(
      EventServiceCreateEventResponse eventResponse,
      List<TicketServiceCreateTicketTypeResponse> ticketResponses) {

    CreateEventResponse res = new CreateEventResponse();

    res.setEventId(eventResponse.getEventId());
    res.setName(eventResponse.getName());
    res.setVenue(eventResponse.getVenue());
    res.setDescription(eventResponse.getDescription());
    res.setStatus(eventResponse.getStatus());
    res.setEventStartDate(eventResponse.getEventStartDate());
    res.setEventEndDate(eventResponse.getEventEndDate());
    res.setSalesStartDate(eventResponse.getSalesStartDate());
    res.setSalesEndDate(eventResponse.getSalesEndDate());
    res.setCreatedAt(eventResponse.getCreatedAt());
    res.setUpdatedAt(eventResponse.getUpdatedAt());

    res.setTicketTypes(ticketResponses == null ? List.of() : ticketResponses);

    return res;
  }
}
